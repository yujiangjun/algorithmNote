## 二叉树

### 数据结构

```java
class Node{
    V value;
    Node left;
    Node right;
}
```

### 遍历

1. 先序：任何子树的处理顺序都是，头结点->左子树->右子树
2. 中序：任何子树的处理顺序都是，左子树->头结点->右子树
3. 后续：任何子树的处理顺序都是，左子树->右子树->头结点



#### 使用非递归方式完成二叉树的先序后序中序遍历

1. 任何递归函数都可以改成非递归。
2. 使用压栈来替代系统栈来实现。

#### 实现二叉树的按层遍历

1. 宽度优先遍历，使用队列
2. 可以通过设置flag变量的方式来发现某一层的结束

#### 实现二叉树的序列化和反序列化

1. 先序方式序列化和反序列化
2. 按层方式序列化和反序列化

### 常用面试题

1. leetcode 431

2. 设计一个打印整棵树的打印函数

3. 二叉树的最宽层有多少个节点

4. >二叉树结构如下定义：
   >
   >```java
   >Class Node {
   >	V value;
   >	Node left;
   >	Node right;
   >	Node parent;
   >}
   >```
   >
   >给你二叉树中的某个节点，返回该节点的后继节点

5. >
   >
   >请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。 给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。 例如:N=1时，打印: down N=2时，打印: down down up 

6. 判断二叉树是否是完全二叉树（二叉树的递归套路）



### 二叉树的递归套路

*可以解决面试中绝大多数的二叉树问题尤其是树形DP问题，本质是利用递归遍历二叉树的便利性。*

1. 假设以X节点为头，假设可以向X左树和X右树要任何信息
2. 在上一步的假设下，讨论以X为头结点的树，得到答案的可能性
3. 列出所有的可能性后，确定到底需要向左树和右树要什么样的信息
4. 把左树和右树信息求全集，就是任何一颗子树都需要返回的信息S
5. 递归函数都返回S，任何一颗子树都这么要求
6. 写代码，在代码中考虑如何把左树信息和右树信息整合出整棵树的信息

#### 相关题目

1. 判断二叉树是否是搜索二叉树

2. 给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树

3. 给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树

4. 给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小

5. 给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离

6. 判断二叉树是否是完全二叉树

7. 给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点

8. 给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先

9. >
   >
   >派对的最大快乐值
   >
   >员工的信息定义如下
   >
   >```java
   >class Employee{
   >    public int happy;//这名员工可以带来的快乐值
   >    List<Employee> subordinates;// 这名员工有哪些直接下属
   >}
   >```
   >
   >派对的最大快乐值 公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级
   >
   >
   >
   >派对的最大快乐值这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，
   >
   >规则：
   >
   >1. 如果某个员工来了，那么这个员工的所有直接下级都不能来
   >2. 派对的整体快乐值是所有到场员工快乐值的累加
   >3. 你的目标是让派对的整体快乐值尽量大给定一棵多叉树的头节点boss，请返回派对的最大快乐值。

   