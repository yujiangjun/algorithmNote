## 动态规划

### 暴力递归

1. 把问题转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件(base case)
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解

>什么暴力递归可以继续优化？
>
>1. 有重复调用同一个子问题的解，这种递归可以优化。
>2. 如果每一个子问题都是不同的解，无法优化也不用优化。



>暴力递归和动态规划的关系
>
>某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化城动态规划。
>
>任何动态规划问题，都一定对应着某一个有重复过程的暴力递归
>
>但不是所有的暴力递归，都一定对应着动态规划。
>
>**所以 动态规划一定可以由暴力递归改造过来，但是暴力递归不一定能改成动态规划**







> 如何找到某个问题的动态规划方式？
>
> 1. 设计暴力递归：重要原则+4个常见的尝试模型
> 2. 分析有没有重复解
> 3. 用记忆化搜索->严格表结构实现动态规划
> 4. 看看能否继续优化：套路解决





> 面试中设计暴力递归过程的原则
>
> 1. 每一个可变参数的类型，一定不要比int类型更加复杂
> 2. 原则1可以违反，让类型拖坡道一维线性结构，那必须是单一可变参数
> 3. 如果发现原则1违反，但是不违反原则2，只需要做到记忆化搜索即可
> 4. 可变参数的个数，能少则少

### 常见的4种尝试模型

1. 从左到右的尝试模型
2. 范围尝试模型
3. 多样本位置全对应的尝试模型
4. 寻找业务限制的尝试模型

### 暴力递归到动态规划的套路

1. 你已经有了一个不违反原则的暴力递归，而且存在解的重复调用
2. 找到哪些参数的变化为影响返回值，对每一个列出变化范围
3. 参数间的所有组合数量，意味着表的大小
4. 记忆化搜索的方法就是傻缓存，
5. 规定和严格的表的大小，分析位置的依赖顺序，然后从基础填写到最终解
6. 对于有枚举行为的决策过程，进一步优化



### 动态规划的进一步优化

1. 空间压缩
2. 状态花间
3. 四边形不等式
4. 其他优化技巧



### 四边形不等式技巧

1. 两个可变参数的区间划分问题
2. 每个格子有枚举行为
3. 当两个可变参数固定一个，另一个参数和答案之间存在单调性关系
4. 而且两组单调性关系是反向的：(升升，降降)（升 降， 降 升）
5. 能否获得指导枚举优化的位置对：上+右 或者 左+下



#### 相关题目(四边形不等式)

1. > 摆放着n堆石子。现要将石子有次序地合并成一堆规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分求出将n堆石子合并成一堆的最小得分（或最大得分）合并方案

2. > 给定一个整型数组 arr，数组中的每个值都为正数，表示完成一幅画作需要的时间，再 给定 一个整数 num，表示画匠的数量，每个画匠只能画连在一起的画作。所有的画家 并行工作，请 返回完成所有的画作需要的最少时间。【举例】arr=[3,1,4]，num=2。最好的分配方式为第一个画匠画 3 和 1，所需时间为 4。第二个画匠画 4，所需时间 为 4。 因为并行工作，所以最少时间为 4。如果分配方式为第一个画匠画 3，所需时 间为 3。第二个画 匠画 1 和 4，所需的时间为 5。那么最少时间为 5，显然没有第一 种分配方式好。所以返回 4。arr=[1,1,1,4,3]，num=3。最好的分配方式为第一个画匠画前三个 1，所需时间为 3。第二个画匠画 4，所需时间 为 4。 第三个画匠画 3，所需时间为 3。返回 4。

3. > 一条直线上有居民点，邮局只能建在居民点上。给定一个有序正数数组arr，每个值表示 居民点的一维坐标，再给定一个正数 num，表示邮局数量。选择num个居民点建立num个 邮局，使所有的居民点到最近邮局的总距离最短，返回最短的总距离【举例】arr=[1,2,3,4,5,1000]，num=2。第一个邮局建立在 3 位置，第二个邮局建立在 1000 位置。那么 1 位置到邮局的距离 为 2， 2 位置到邮局距离为 1，3 位置到邮局的距离为 0，4 位置到邮局的距离为 1， 5 位置到邮局的距 离为 2，1000 位置到邮局的距离为 0。这种方案下的总距离为 6， 其他任何方案的总距离都不会 比该方案的总距离更短，所以返回6

4. > 一座大楼有 0~N 层，地面算作第 0 层，最高的一层为第 N 层。已知棋子从第 0 层掉落肯定 不会摔碎，从第 i 层掉落可能会摔碎，也可能不会摔碎(1≤i≤N)。给定整数 N 作为楼层数， 再给定整数 K 作为棋子数，返 回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔 的最少次数。一次只能扔一个棋子。【举例】N=10，K=1。返回 10。因为只有 1 棵棋子，所以不得不从第 1 层开始一直试到第 10 层，在最差的情况 下，即第 10 层 是不会摔坏的最高层，最少也要扔 10 次。N=3，K=2。返回 2。先在 2 层扔 1 棵棋子，如果碎了，试第 1 层，如果没碎，试第 3 层。 N=105，K=2 返回 14。第一个棋子先在 14 层扔，碎了则用仅存的一个棋子试 1~13。 若没碎，第一个棋子继续在 27 层扔，碎了则 用仅存的一个棋子试 15~26。 若没碎，第一个棋子继续在 39 层扔，碎了则用仅存的一个棋子试 28~38。 若 没碎，第一个棋子继续在 50 层扔，碎了则用仅存的一个棋子试 40~49。 若没碎，第一个棋子继续在 60 层扔， 碎了则用仅存的一个棋子试 51~59。 若没碎，第一个棋子继续在 69 层扔，碎了则用仅存的一个棋子试 61~68。 若没碎，第一个棋子继续在 77 层扔，碎了则用仅存的一个棋子试 70~76。 若没碎，第一个棋子继续在 84 层 扔，碎了则用仅存的一个棋子试 78~83。 若没碎，第一个棋子继续在 90 层扔，碎了则用仅存的一个棋子试 85~89。 若没碎，第一个棋子继续在 95 层扔，碎了则用仅存的一个棋子试 91~94。 若没碎，第一个棋子继续 在 99 层扔，碎了则用仅存的一个棋子试 96~98。 若没碎，第一个棋子继续在 102 层扔，碎了则用仅存的一 个棋子试 100、101。 若没碎，第一个棋子继续在 104 层扔，碎了则用仅存的一个棋子试 103。 若没碎，第 一个棋子继续在 105 层扔，若到这一步还没碎，那么 105 便是结果。

5. > Leetcode    464

6. > TSP问题 有N个城市，任何两个城市之间的都有距离，任何一座城市到自己的距离都为0。所有点到点的距 离都存在一个N*N的二维数组matrix里，也就是整张图由邻接矩阵表示。现要求一旅行商从k城市 出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的k城，返回总距离最短的路的 距离。参数给定一个matrix，给定k。

7. > 你有无限的1*2的砖块，要铺满M*N的区域，不同的铺法有多少种?
