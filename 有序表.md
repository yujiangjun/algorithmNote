## 有序表

搜索二叉树

查询key

> 1. 如果当前节点的value==key,则返回true
> 2. 如果当前节点的value<key,当前节点向左移动
> 3. 如果当前节点的value>key,当前节点向右移动
> 4. 如果当前节点变成null，则返回false



查询新的key

> 和查询过程一样，但当前节点滑动空的时候，就插入在这里



删除key

> 1. 先找到key所在的节点
> 2. 如果该节点没有左孩子、没有右孩子，则直接删除
> 3. 如果该节点有左孩子，没有右孩子，则直接用左孩子顶替该节点
> 4. 如果该节点没有左孩子，有右孩子，则直接用右孩子顶替该节点
> 5. 如果该节点有左孩子，有右孩子，用该节点的后继结点顶替该节点



AVL树、SB树、红黑树的共性

1. 都是搜索二叉树
2. 插入、删除、插叙搜索二叉树怎么做，这些结构都这么做
3. 使用调整的基本动作都只有左旋，右旋
4. 插入、删除时，从最底层被影响到的节点开始，对往上路径的节点做平衡性检查
5. 因为只对一条向上路径的每个节点做O(1)的检查和调整，所以可以做到O(logN)





AVL树、SB树、红黑树的不同

1. 平衡性的约束不同
   1. AVL树最严格，SB树稍宽松、红黑树最宽松
2. 插入、删除和搜索二叉树一样，但是额外，做各自平衡性调整。各自平衡性调整所使用的动作都是左旋或者是右旋。



AVL树

1. 最严格的平衡性，任何节点左树高度和右树高度差不超过1
2. 往上沿途检查每个节点时，都去检查四种违规情况，LL、RR、LR、RL
3. 不同情况虽然看起来复杂，但是核心点事
   1. LL做一次右旋
   2. RR做一次左旋
   3. LR和RL利用旋转让底层那个上到顶部。

SB树

1. 让每一个叔叔节点为头的数，节点个数都不少于其任何一个侄子节点
2. 也是从底层被影响节点开始向上做路径每个节点检查
3. 与AVL树非常像，也是四种违规类型：LL、RR、LR、RL
4. 与AVL树非常像，核心点是：LL做一次右旋、RR做一次左旋、LR和RL利用旋转让底层那个上到顶部
5. 与AVL树不同的是，每轮经过调整后，谁的孩子发生了变化，谁就在查

SB树在使用时候的改进

1. 删除时候可以不用检查
2. 就把平衡性的调整放在插入的时候
3. 因为这种只要变就递归的特性，别的树没有
4. 可以在节点上肥壮别的数据项，来增加功能

跳表(SkipList)

1. 结构上根本和搜索二叉树无关
2. 利用随机概率分布来使用高度索引可以无视数据规律，做到整体性能优良
3. 思想树所有有序表中最先进的
4. 结构简单就是多级单链表

红黑树

1. 平衡性规定非常诡异
2. 平衡性调整最为复杂
3. 有点在于每次插入删除扰动较好，
4. 红黑树并不比AVL树，SB树，跳表更加优秀



### 相关题目

1. > 给定一个数组arr，和两个整数a和b（a<=b）求arr中有多少个子数组，累加和在[a,b]这个范围上返回达标的子数组数量

2. > 有一个滑动窗口（讲过的）：1）L是滑动窗口最左位置、R是滑动窗口最右位置，一开始LR都在数组左侧2）任何一步都可能R往右动，表示某个数进了窗口3）任何一步都可能L往右动，表示某个数出了窗口想知道每一个窗口状态的中位数

3. > 设计一个结构包含如下两个方法：void add(int index, int num)：把num加入到index位置int get(int index) ：取出index位置的值void remove(int index) ：把index位置上的值删除要求三个方法时间复杂度O(logN)



### 改写有序表题目的核心

1. 分析增加什么数据项可以支持题目
2. 有序表一定要保持内部参与排序的key不重复
3. 增加这个数据项了，在平衡性调整时，保证这个数据项也能更新正确

